/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                                                                                   ///
///  MCMC Functions for Particle Filter Based Fitting of Stochastic Mosquito Model                    ///
///                                                                                                   ///
///  Charlie Whittaker                                                                                ///
///  Imperial College London                                                                          ///
///  charles.whittaker16@imperial.ac.uk                                                               ///
///                                                                                                   ///
///  The below represents a series of functions that are required to implement a modified, adaptive   ///
///  Metropolis-Hastings MCMC framework that incorporates a Particle Filter to calculate the          ///
///  likelihood of a particular set of model parameters.                                              ///
///                                                                                                   ///
///  Specifically, the code specifies a number of functions. These are:                               ///
///                                                                                                   ///
///       1) prior - Returns the probability density of a parameter set given a particular set        ///
///          of Priors.                                                                               ///
///       2) likelihood_function - Returns the likelihood of the model output generated by a          ///
///          specific parameter set. This likelihood is calculated by running the Particle Filter.    ///
///       3) posterior_joint_proposals - Returns the overall Posterior Density for the parameter      ///
///          set, which represents a combination of the Prior density and the Model Likelihood.       ///
///          Binomial distribution with specified properties.                                         ///
///       4) joint_proposal_SD_adapter - Function to adapt the covariance matrix involved in the      ///
///          proposal function used in the MCMC.                                                      ///
///       5) mvrnormArma - Function to return a sample from a multivariate normal distribution        ///
///          with a specified mean vector and specified covariance matrix, using a Cholesky           ///
///          Decomposition. Also contains capacity to handle instances when the covariance matrix     ///
///          is non-invertible (adding a small value to the diagonal).                                ///
///                                                                                                   ///
///                                                                                                   ///
/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////

// Specifying the Includes and Depends Required
#include "Particle_Filter_Functions.hpp"
#include <RcppArmadillo.h>
// [[Rcpp::depends(RcppArmadillo)]]

//' @export
// [[Rcpp::export]]
double prior(Rcpp::NumericVector parameter_values, Rcpp::LogicalVector fitted_yn, Rcpp::String likelihood_choice) {

  double res = 0;
  bool overdisp = true;

  if (likelihood_choice == "poisson") {
    overdisp = false;
  }

  if (fitted_yn["dE"]) {
    res = res + R::dnorm4(parameter_values["dE"], 6.64, 0.933, TRUE); //dE - Michael's Posterior
  }
  if (fitted_yn["dL"]) {
    res = res + R::dnorm4(parameter_values["dL"], 3.72, 0.862, TRUE); //dL - Michael's Posterior
  }
  if (fitted_yn["dP"]) {
    res = res + R::dnorm4(parameter_values["dP"], 0.64, 0.291, TRUE); //dP - Michael's Posterior
  }
  if (fitted_yn["muE0"]) {
    res = res + R::dnorm4(parameter_values["muE0"], 0.034, 0.0056, TRUE); //muE0 - Michael's Posterior
  }
  if (fitted_yn["muL0"]) {
    res = res + R::dnorm4(parameter_values["muL0"], 0.035, 0.0056, TRUE); //muL0 - Michael's Posterior
  }
  if (fitted_yn["muP"]) {
    res = res + R::dnorm4(parameter_values["muP"], 0.25, 0.03571, TRUE); //muP - Michael's Posterior
  }
  if (fitted_yn["muM"]) {
    res = res + R::dnorm4(parameter_values["muM"], 0.096, 0.00459, TRUE); //muM - Michael's Posterior
  }
  if (fitted_yn["lambda"]) {
    res = res + R::dnorm4(parameter_values["lambda"], 13.25, 5, TRUE); //lambda - NOT Michael's Posterior
  }
  if (fitted_yn["beta"]) {
    res = res + R::dnorm4(parameter_values["beta"], 21.19, 4.9082, TRUE); //beta - Michael's Posterior
  }
  if (overdisp == true && fitted_yn["overdisp"]) {
    res = res + R::dnorm4(parameter_values["overdisp"], 1, 0.5, TRUE); //overdispersion
  }
  if (fitted_yn["pop_frac"]) {
    res = res + R::dbeta(parameter_values["pop_frac"], 0.2750417, 5.8075736, TRUE); //pop_frac BETA DISTRIBUTION USED BASED ON MRR DATA
  }
  if (fitted_yn["z"]) {
    res = res + R::dunif(parameter_values["z"], 1, 10000, TRUE); //pop_frac BETA DISTRIBUTION USED BASED ON MRR DATA
  }
  if (fitted_yn["tau_rainfall"]) {
    res = res + R::dnorm4(parameter_values["tau_rainfall"], 4, 0.7653, TRUE); // CONSIDER CHANGING THIS
  }
  if (fitted_yn["scaling_factor_rainfall"]) {
    res = res + R::dunif(parameter_values["scaling_factor_rainfall"], 1, 500, TRUE); //pop_frac BETA DISTRIBUTION USED BASED ON MRR DATA
  }
  if (fitted_yn["K_Max_Hill_Rainfall"]) {
    res = res + R::dunif(parameter_values["K_Max_Hill_Rainfall"], 1, 500, TRUE); //pop_frac BETA DISTRIBUTION USED BASED ON MRR DATA
  }
  if (fitted_yn["Hill_Rainfall_1"]) {
    res = res + R::dunif(parameter_values["Hill_Rainfall_1"], 1, 500, TRUE); //pop_frac BETA DISTRIBUTION USED BASED ON MRR DATA
  }
  if (fitted_yn["Hill_Rainfall_2"]) {
    res = res + R::dunif(parameter_values["Hill_Rainfall_2"], 1, 500, TRUE); //pop_frac BETA DISTRIBUTION USED BASED ON MRR DATA
  }
  if (fitted_yn["tau_static"]) {
    res = res + R::dunif(parameter_values["tau_static"], 2, 100, TRUE);
  }
  if (fitted_yn["scaling_factor_static"]) {
    res = res + R::dunif(parameter_values["scaling_factor_static"], 1, 500, TRUE); //pop_frac BETA DISTRIBUTION USED BASED ON MRR DATA
  }
  if (fitted_yn["K_Max_Static"]) {
    res = res + R::dunif(parameter_values["K_Max_Static"], 0, 200, TRUE);
  }
  if (fitted_yn["Washout_Threshold"]) {
    res = res + R::dunif(parameter_values["Washout_Threshold"], 0, 10, TRUE);
  }
  if (fitted_yn["Washout_Exp_Decline"]) {
    res = res + R::dunif(parameter_values["Washout_Exp_Decline"], 0.00001, 1, TRUE); //z Uniform distribution used
  }
  if (fitted_yn["Washout_Hill_1"]) {
    res = res + R::dunif(parameter_values["Washout_Hill_1"], -200, 200, TRUE); //z Uniform distribution used
  }
  if (fitted_yn["Washout_Hill_2"]) {
    res = res + R::dunif(parameter_values["Washout_Hill_2"], -200, 200, TRUE); //z Uniform distribution used
  }
  return(res);
}

//' @export
// [[Rcpp::export]]
double likelihood(int N, std::vector <int> obsData,
                           Rcpp::NumericVector fitted_parameters, Rcpp::NumericVector static_parameters,
                           std::vector <double> rainfall,
                           Rcpp::String mortality_density_function, Rcpp::String rainfall_relationship,
                           Rcpp::String rainfall_effect, Rcpp::String decline_type,
                           double sampling_point, Rcpp::StringVector offset_month_vector,
                           Rcpp::StringVector sampling_month_vector, Rcpp::String likelihood_choice,
                           Rcpp::String calc_inside_mosquito_model) {

  double loglikelihood =   min_output_particle_filter(N, obsData, fitted_parameters, static_parameters,
                                                      rainfall,
                                                      mortality_density_function, rainfall_relationship,
                                                      rainfall_effect, decline_type,
                                                      sampling_point, offset_month_vector,
                                                      sampling_month_vector, likelihood_choice, calc_inside_mosquito_model);
  return(loglikelihood);

}

//' @export
// [[Rcpp::export]]
double posterior(int N, std::vector <int> obsData,
                Rcpp::NumericVector fitted_parameters, Rcpp::NumericVector static_parameters,
                std::vector <double> rainfall,
                Rcpp::LogicalVector fitted_yn,
                Rcpp::String mortality_density_function, Rcpp::String rainfall_relationship,
                Rcpp::String rainfall_effect, Rcpp::String decline_type,
                double sampling_point, Rcpp::StringVector offset_month_vector,
                Rcpp::StringVector sampling_month_vector, Rcpp::String likelihood_choice,
                Rcpp::String calc_inside_mosquito_model) {

  double posterior_likelihood;

  if (prior(fitted_parameters, fitted_yn, likelihood_choice) < -5000) {
    posterior_likelihood = -10000;
    return(posterior_likelihood);
  }

  else {
    posterior_likelihood = likelihood(N, obsData,
                                      fitted_parameters, static_parameters,
                                      rainfall,
                                      mortality_density_function, rainfall_relationship, rainfall_effect, decline_type,
                                      sampling_point, offset_month_vector, sampling_month_vector,
                                      likelihood_choice, calc_inside_mosquito_model)
                           + prior(fitted_parameters, fitted_yn, likelihood_choice);
    return(posterior_likelihood);
  }

}

// BOTH MU_PREVIOUS AND CURRENT_PARAMETERS NEED TO BE ROW VECTORS

//' @export
// [[Rcpp::export]]
Rcpp::List proposal_SD_adapter(double accepted_variable, double current_iteration, double iteration_cooling_began,
                               double current_scaling_factor, arma::mat mu_previous, arma::mat current_parameter_values, // technically parameter values for t + 1 as the acceptance/rejection step precedes calling this function
                               arma::mat current_covariance_matrix) {

  double iterations_since_cooling_began = current_iteration - iteration_cooling_began;
  double cooldown = pow((iterations_since_cooling_began + 1), -0.6);

  arma::mat new_correlation_matrix = ((1 - cooldown) * current_covariance_matrix) + (cooldown * (((current_parameter_values - mu_previous).t()) * (current_parameter_values - mu_previous)));
  arma::mat new_mu = ((1 - cooldown) * mu_previous) + (cooldown * current_parameter_values);
  double log_new_scaling_factor = log(current_scaling_factor) + cooldown * (accepted_variable - 0.25);
  double new_scaling_factor = exp(log_new_scaling_factor);
  arma::mat new_covariance_matrix = new_scaling_factor * new_correlation_matrix;

  return(Rcpp::List::create(Rcpp::Named("New_Covariance_Matrix") = new_covariance_matrix,
                            Rcpp::Named("New_Mu") = new_mu,
                            Rcpp::Named("New_Scaling_Factor") = new_scaling_factor,
                            Rcpp::Named("Cooldown") = cooldown));

}

// [[Rcpp::export]]
arma::mat mvrnormArma(arma::mat mu, arma::mat sigma) {

  int ncols = sigma.n_cols;
  arma::mat Y = arma::randn(1, ncols);
  arma::vec eigenvalues_calc = arma::eig_sym(sigma);
  double minimum = eigenvalues_calc.min();

  if (minimum <= 0.0) {

    for (int i = 0; i < ncols; i++) {
      for (int j = 0; j < ncols; j++) {
        if (i == j) {
          sigma(i,j) = sigma(i, j) + 0.01;
        }
      }
    }
    arma::vec new_eigenvalues_calc = arma::eig_sym(sigma);
    double new_minimum = eigenvalues_calc.min();

    if (new_minimum <= 0.0) {

      for (int i = 0; i < ncols; i++) {
        for (int j = 0; j < ncols; j++) {
          if (i == j) {
            sigma(i,j) = sigma(i, j) + 0.1;
          }
        }
      }
    }

    arma::mat MVN_samples = mu + Y * arma::chol(sigma);
    for (int i = 0; i < MVN_samples.size(); i++) {
      if (MVN_samples(0, i) < 0) {
        MVN_samples(0, i) = 0;
      }
    }
    return(MVN_samples);
  }

  // this next bit is a placeholder until I can get the truncated normal going.
  // prevents it from returning negative numbers
  else {

    arma::mat MVN_samples = mu + Y * arma::chol(sigma);
    for (int i = 0; i < MVN_samples.size(); i++) {
      if (MVN_samples(0, i) < 0) {
        MVN_samples(0, i) = 0;
      }
    }
    return(MVN_samples);
  }

}


