/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                                                                                   ///
///  MCMC Functions for Particle Filter Based Fitting of Stochastic Mosquito Model                    ///
///                                                                                                   ///
///  Charlie Whittaker                                                                                ///
///  Imperial College London                                                                          ///
///  charles.whittaker16@imperial.ac.uk                                                               ///
///                                                                                                   ///
///  The below represents a series of functions that are required to implement a modified, adaptive   ///
///  Metropolis-Hastings MCMC framework that incorporates a Particle Filter to calculate the          ///
///  likelihood of a particular set of model parameters.                                              ///
///                                                                                                   ///
///  Specifically, the code specifies a number of functions. These are:                               ///
///                                                                                                   ///
///       1) prior - Returns the probability density of a parameter set given a particular set        ///
///          of Priors.                                                                               ///
///       2) likelihood_function - Returns the likelihood of the model output generated by a          ///
///          specific parameter set. This likelihood is calculated by running the Particle Filter.    ///
///       3) posterior_joint_proposals - Returns the overall Posterior Density for the parameter      ///
///          set, which represents a combination of the Prior density and the Model Likelihood.       ///
///          Binomial distribution with specified properties.                                         ///
///       4) joint_proposal_SD_adapter - Function to adapt the covariance matrix involved in the      ///
///          proposal function used in the MCMC.                                                      ///
///       5) mvrnormArma - Function to return a sample from a multivariate normal distribution        ///
///          with a specified mean vector and specified covariance matrix, using a Cholesky           ///
///          Decomposition. Also contains capacity to handle instances when the covariance matrix     ///
///          is non-invertible (adding a small value to the diagonal).                                ///
///                                                                                                   ///
///                                                                                                   ///
/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////

// Specifying the Includes and Depends Required
#include "Particle_Filter_Functions.hpp"
#include <RcppArmadillo.h>
// [[Rcpp::depends(RcppArmadillo)]]

//' @export
// [[Rcpp::export]]
double prior(Rcpp::NumericVector parameter_values, Rcpp::LogicalVector fitted_yn, Rcpp::String likelihood_choice) {

  double res = 0;
  bool overdisp = true;

  if (likelihood_choice == "poisson") {
    overdisp = false;
  }

  if (fitted_yn["dE"]) {
    res = res + R::dnorm4(parameter_values["dE"], 6.64, 0.933, TRUE); //dE - Michael's Posterior
  }
  if (fitted_yn["dL"]) {
    res = res + R::dnorm4(parameter_values["dL"], 3.72, 0.862, TRUE); //dL - Michael's Posterior
  }
  if (fitted_yn["dP"]) {
    res = res + R::dnorm4(parameter_values["dP"], 0.64, 0.291, TRUE); //dP - Michael's Posterior
  }
  if (fitted_yn["muE0"]) {
    res = res + R::dnorm4(parameter_values["muE0"], 0.034, 0.0056, TRUE); //muE0 - Michael's Posterior
  }
  if (fitted_yn["muL0"]) {
    res = res + R::dnorm4(parameter_values["muL0"], 0.035, 0.0056, TRUE); //muL0 - Michael's Posterior
  }
  if (fitted_yn["muP"]) {
    res = res + R::dnorm4(parameter_values["muP"], 0.25, 0.03571, TRUE); //muP - Michael's Posterior
  }
  if (fitted_yn["muM"]) {
    res = res + R::dnorm4(parameter_values["muM"], 0.096, 0.00459, TRUE); //muM - Michael's Posterior
  }
  if (fitted_yn["lambda"]) {
    res = res + R::dnorm4(parameter_values["lambda"], 13.25, 5, TRUE); //lambda - NOT Michael's Posterior
  }
  if (fitted_yn["beta"]) {
    res = res + R::dnorm4(parameter_values["beta"], 21.19, 4.9082, TRUE); //beta - Michael's Posterior
  }
  if (overdisp == true && fitted_yn["overdisp"]) {
    res = res + R::dnorm4(parameter_values["overdisp"], 1, 0.5, TRUE); //overdispersion
  }
  if (fitted_yn["pop_frac"]) {
    res = res + R::dbeta(parameter_values["pop_frac"], 0.2750417, 5.8075736, TRUE); //pop_frac BETA DISTRIBUTION USED BASED ON MRR DATA
  }
  if (fitted_yn["z"]) {
    res = res + R::dunif(parameter_values["z"], 1, 10000, TRUE); //pop_frac BETA DISTRIBUTION USED BASED ON MRR DATA
  }
  if (fitted_yn["tau_rainfall"]) {
    res = res + R::dnorm4(parameter_values["tau_rainfall"], 4, 0.7653, TRUE); // CONSIDER CHANGING THIS
  }
  if (fitted_yn["scaling_factor_rainfall"]) {
    res = res + R::dunif(parameter_values["scaling_factor_rainfall"], 1, 500, TRUE); //pop_frac BETA DISTRIBUTION USED BASED ON MRR DATA
  }
  if (fitted_yn["K_Max_Hill_Rainfall"]) {
    res = res + R::dunif(parameter_values["K_Max_Hill_Rainfall"], 1, 500, TRUE); //pop_frac BETA DISTRIBUTION USED BASED ON MRR DATA
  }
  if (fitted_yn["Hill_Rainfall_1"]) {
    res = res + R::dunif(parameter_values["Hill_Rainfall_1"], 1, 500, TRUE); //pop_frac BETA DISTRIBUTION USED BASED ON MRR DATA
  }
  if (fitted_yn["Hill_Rainfall_2"]) {
    res = res + R::dunif(parameter_values["Hill_Rainfall_2"], 1, 500, TRUE); //pop_frac BETA DISTRIBUTION USED BASED ON MRR DATA
  }
  if (fitted_yn["tau_static"]) {
    res = res + R::dunif(parameter_values["tau_static"], 2, 100, TRUE);
  }
  if (fitted_yn["scaling_factor_static"]) {
    res = res + R::dunif(parameter_values["scaling_factor_static"], 1, 500, TRUE); //pop_frac BETA DISTRIBUTION USED BASED ON MRR DATA
  }
  if (fitted_yn["K_Max_Static"]) {
    res = res + R::dunif(parameter_values["K_Max_Static"], 0, 200, TRUE);
  }
  if (fitted_yn["Washout_Threshold"]) {
    res = res + R::dunif(parameter_values["Washout_Threshold"], 0, 10, TRUE);
  }
  if (fitted_yn["Washout_Exp_Decline"]) {
    res = res + R::dunif(parameter_values["Washout_Exp_Decline"], 0.00001, 1, TRUE); //z Uniform distribution used
  }
  if (fitted_yn["Washout_Hill_1"]) {
    res = res + R::dunif(parameter_values["Washout_Hill_1"], -200, 200, TRUE); //z Uniform distribution used
  }
  if (fitted_yn["Washout_Hill_2"]) {
    res = res + R::dunif(parameter_values["Washout_Hill_2"], -200, 200, TRUE); //z Uniform distribution used
  }
  return(res);
}

//' @export
// [[Rcpp::export]]
double likelihood(int N, std::vector <int> obsData,
                           Rcpp::NumericVector fitted_parameters, Rcpp::NumericVector static_parameters,
                           std::vector <double> rainfall,
                           Rcpp::String mortality_density_function, Rcpp::String rainfall_relationship,
                           Rcpp::String rainfall_effect, Rcpp::String decline_type,
                           double sampling_point, Rcpp::StringVector offset_month_vector,
                           Rcpp::StringVector sampling_month_vector, Rcpp::String likelihood_choice,
                           Rcpp::String calc_inside_mosquito_model) {

  double loglikelihood =   min_output_particle_filter(N, obsData, fitted_parameters, static_parameters,
                                                      rainfall,
                                                      mortality_density_function, rainfall_relationship,
                                                      rainfall_effect, decline_type,
                                                      sampling_point, offset_month_vector,
                                                      sampling_month_vector, likelihood_choice, calc_inside_mosquito_model);
  return(loglikelihood);

}

//' @export
// [[Rcpp::export]]
double posterior(int N, std::vector <int> obsData,
                Rcpp::NumericVector fitted_parameters, Rcpp::NumericVector static_parameters,
                std::vector <double> rainfall,
                Rcpp::LogicalVector fitted_yn,
                Rcpp::String mortality_density_function, Rcpp::String rainfall_relationship,
                Rcpp::String rainfall_effect, Rcpp::String decline_type,
                double sampling_point, Rcpp::StringVector offset_month_vector,
                Rcpp::StringVector sampling_month_vector, Rcpp::String likelihood_choice,
                Rcpp::String calc_inside_mosquito_model) {

  double posterior_likelihood;

  if (prior(fitted_parameters, fitted_yn, likelihood_choice) < -5000) {
    posterior_likelihood = -10000;
    return(posterior_likelihood);
  }

  else {
    posterior_likelihood = likelihood(N, obsData,
                                      fitted_parameters, static_parameters,
                                      rainfall,
                                      mortality_density_function, rainfall_relationship, rainfall_effect, decline_type,
                                      sampling_point, offset_month_vector, sampling_month_vector,
                                      likelihood_choice, calc_inside_mosquito_model)
                           + prior(fitted_parameters, fitted_yn, likelihood_choice);
    return(posterior_likelihood);
  }

}

// BOTH MU_PREVIOUS AND CURRENT_PARAMETERS NEED TO BE ROW VECTORS

//' @export
// [[Rcpp::export]]
Rcpp::List proposal_SD_adapter(double accepted_variable, double current_iteration, double iteration_cooling_began,
                               double current_scaling_factor, arma::mat mu_previous, arma::mat current_parameter_values, // technically parameter values for t + 1 as the acceptance/rejection step precedes calling this function
                               arma::mat current_covariance_matrix) {

  double iterations_since_cooling_began = current_iteration - iteration_cooling_began;
  double cooldown = pow((iterations_since_cooling_began + 1), -0.6);

  arma::mat new_correlation_matrix = ((1 - cooldown) * current_covariance_matrix) + (cooldown * (((current_parameter_values - mu_previous).t()) * (current_parameter_values - mu_previous)));
  arma::mat new_mu = ((1 - cooldown) * mu_previous) + (cooldown * current_parameter_values);
  double log_new_scaling_factor = log(current_scaling_factor) + cooldown * (accepted_variable - 0.25);
  double new_scaling_factor = exp(log_new_scaling_factor);
  arma::mat new_covariance_matrix = new_scaling_factor * new_correlation_matrix;

  return(Rcpp::List::create(Rcpp::Named("New_Covariance_Matrix") = new_covariance_matrix,
                            Rcpp::Named("New_Mu") = new_mu,
                            Rcpp::Named("New_Scaling_Factor") = new_scaling_factor,
                            Rcpp::Named("Cooldown") = cooldown));

}

// [[Rcpp::export]]
arma::mat mvrnormArma(arma::mat mu, arma::mat sigma) {

  // Initialising variables required for the Cholesky Decomposition
  int ncols = sigma.n_cols;
  arma::mat Y = arma::randn(ncols, 1);

  //Rcpp::Rcout << "The column vector of normals is " << Y << std::endl;

  // Checking whether sigma has negative eigenvalues (hence precluding Cholesky Decompisition which
  // requires taking the inverse) - if it does, I do the following things:
  //      1) Check whether any of the eigenvalues are very small and positive/negative (order of 1^-12). In
  //         which case, change these back to 0. Do the Eigendecomposition.
  //      2) Sequentially add some small amount along the diagonal (e.g. as suggested here:
  //         https://arxiv.org/pdf/1006.3690.pdf page 12 section 5.2). Specifically, I first increase
  //         increases the amount along the diagonal by 1% and if that doesn't solve the problem, by 10%.
  //         Then do the Cholesky Decomposition.
  //      3) If this still isn't working, go back to the Eigendecomposition, and set any negative
  //         eigenvalues to 0.01. Then do the Eigendecomposition
  arma::vec eigenvalues_calc;
  arma::mat eigenvectors_calc;
  eig_sym(eigenvalues_calc, eigenvectors_calc, sigma);
  double minimum = eigenvalues_calc.min();

  /////////////////////////////////////////////////////////////////////
  //                                                                 //
  //  1.  Checking whether any eigenvalues are very small. Changing  //
  //      them if they are and doing an eigendecomposition.          //
  //                                                                 //
  /////////////////////////////////////////////////////////////////////

  // Detecting whether any of the eigenvalues are very small
  int small_eigenvalue_detector = 0;
  for (int i = 0; i < ncols; i++) {
    if (eigenvalues_calc[i] <= 1e-12 & eigenvalues_calc[i] >= -1e-12) { // changed to -6 so I can use the matrix I'm using to test, but in the blog post they set it to 1e-12
      small_eigenvalue_detector = 1;
    }
  }

  // If the eigenvalues are very small, changing them to 0 and then do the eigendecomposition
  if (small_eigenvalue_detector == 1) {
    for (int i = 0; i < ncols; i++) {
      if (eigenvalues_calc[i] <= 1e-12 & eigenvalues_calc[i] >= -1e-12) { // changed to -6 so I can use the matrix I'm using to test, but in the blog post they set it to 1e-12
        small_eigenvalue_detector = 1;
        eigenvalues_calc[i] = 0;
      }
    }

    // Create diagional matrix full of zeroes and then fill it with the covariance matrix eigenvalues
    arma::mat eigenvalue_diagonal_matrix = arma::zeros(ncols, ncols); // check that the eigenvalues are added as doubles, not integer
    eigenvalue_diagonal_matrix.diag() = eigenvalues_calc;

    // Perform the eigendecomposition then use it to sample from the MVN
    arma::mat eigenvalue_decomposition = eigenvectors_calc * arma::sqrt(eigenvalue_diagonal_matrix);
    arma::mat MVN_samples = mu + eigenvalue_decomposition * Y;
    arma::mat actual_MVN_samples = MVN_samples.t(); // comes out as column, so trapose to create a row

    for (int i = 0; i < actual_MVN_samples.size(); i++) {
      if (actual_MVN_samples(0, i) < 0) { // don't want negative numbers so sets any negative proposed numbers to 0
        actual_MVN_samples(0, i) = 0;
      }
    }
    return(actual_MVN_samples);
  }

  ///////////////////////////////////////////////////////////////////////////
  //                                                                       //
  //  2.  Sequentially adding a small amount to the diagonal, checking     //
  //      invertibility, and if we're good, doing Chokesly Decomposition   //
  //                                                                       //
  ///////////////////////////////////////////////////////////////////////////

  if (minimum <= 0.0) { // where the matrix does have negative eigenvalues and hence is non-invertible
    arma::mat changed_sigma = sigma; // initialising new matrix with sigma's values so that it can be adapted and not alter the original sigma
    for (int i = 0; i < ncols; i++) {
      for (int j = 0; j < ncols; j++) {
        if (i == j) {
          changed_sigma(i,j) = changed_sigma(i, j) + 0.01 * changed_sigma(i, j);
        }
      }
    }
    arma::vec new_eigenvalues_calc = arma::eig_sym(changed_sigma);
    double new_minimum = new_eigenvalues_calc.min();
    if (new_minimum <= 0.0) {
      for (int i = 0; i < ncols; i++) {
        for (int j = 0; j < ncols; j++) {
          if (i == j) {
            changed_sigma(i,j) = changed_sigma(i, j) + 0.1 * changed_sigma(i, j);
          }
        }
      }
    }
    arma::vec new_new_eigenvalues_calc = arma::eig_sym(changed_sigma);  // does this need to be nested in the same way the new_minimum bit is nested in the original loop
    double new_new_minimum = new_new_eigenvalues_calc.min();
    if (new_new_minimum > 0) {  // implies addition of a small amount has made the matrix invertible now
      arma::mat MVN_samples = mu + arma::chol(changed_sigma) * Y;  // mu is a ncols x 1 column matrix, cholesky is ncols x ncols, Y is ncols x 1
      arma::mat actual_MVN_samples = MVN_samples.t(); // comes out as column, so trapose to create a row
      for (int i = 0; i < actual_MVN_samples.size(); i++) {
        if (actual_MVN_samples(0, i) < 0) { // don't want negative numbers so sets any negative proposed numbers to 0
          actual_MVN_samples(0, i) = 0;
        }
      }
      return(actual_MVN_samples);
    }

    else if (new_new_minimum == 0) { // do an eigendecomposition on the adapted covariance matrix that has lowest eigenvalue 0 now

      arma::vec zero_eigenvalues_calc;
      arma::mat zero_eigenvectors_calc;
      eig_sym(zero_eigenvalues_calc, zero_eigenvectors_calc, changed_sigma);
      double zero_minimum = zero_eigenvalues_calc.min();

      // Create diagional matrix full of zeroes and then fill it with the covariance matrix eigenvalues
      arma::mat zero_eigenvalue_diagonal_matrix = arma::zeros(ncols, ncols); // check that the eigenvalues are added as doubles, not integers
      zero_eigenvalue_diagonal_matrix.diag() = zero_eigenvalues_calc;

      // Perform the eigendecomposition then use it to sample from the MVN
      arma::mat zero_eigenvalue_decomposition = zero_eigenvectors_calc * arma::sqrt(zero_eigenvalue_diagonal_matrix);
      Rcpp::Rcout << "The eigenvalue decomposition matrix is " << zero_eigenvalue_decomposition << std::endl;
      arma::mat MVN_samples = mu + zero_eigenvalue_decomposition * Y;
      arma::mat actual_MVN_samples = MVN_samples.t(); // comes out as column, so trapose to create a row

      for (int i = 0; i < actual_MVN_samples.size(); i++) {
        if (actual_MVN_samples(0, i) < 0) { // don't want negative numbers so sets any negative proposed numbers to 0
          actual_MVN_samples(0, i) = 0;
        }
      }
      return(actual_MVN_samples);
    }

    ////////////////////////////////////////////////////////////////////////////
    //                                                                        //
    //  3.  If that still doesn't work, changing the eigenvectors to a small  //
    //      positive number and then doing the eigendecomposition.            //
    //                                                                        //
    ////////////////////////////////////////////////////////////////////////////

    else {
      for (int i = 0; i < ncols; i++) {
          if (eigenvalues_calc[i] <= 0.0) {
            eigenvalues_calc[i] = 0.01;
          }
        }

      // Create diagional matrix full of zeroes and then fill it with the covariance matrix eigenvalues
      arma::mat eigenvalue_diagonal_matrix = arma::zeros(ncols, ncols); // check that the eigenvalues are added as doubles, not integers
      eigenvalue_diagonal_matrix.diag() = eigenvalues_calc;

      // Perform the eigendecomposition then use it to sample from the MVN
      arma::mat eigenvalue_decomposition = eigenvectors_calc * arma::sqrt(eigenvalue_diagonal_matrix);
      arma::mat MVN_samples = mu + eigenvalue_decomposition * Y;
      arma::mat actual_MVN_samples = MVN_samples.t(); // comes out as column, so trapose to create a row

      for (int i = 0; i < actual_MVN_samples.size(); i++) {
        if (actual_MVN_samples(0, i) < 0) { // don't want negative numbers so sets any negative proposed numbers to 0
          actual_MVN_samples(0, i) = 0;
        }
      }
      return(actual_MVN_samples);
    }
  }
  else {  // for instances where the covariance matrix is invertible and so I can sample using the CHolesky Decomposition directly
    arma::mat MVN_samples = mu + arma::chol(sigma) * Y;
    arma::mat actual_MVN_samples = MVN_samples.t(); // comes out as column, so trapose to create a row
    for (int i = 0; i < actual_MVN_samples.size(); i++) {
      if (actual_MVN_samples(0, i) < 0) {
        actual_MVN_samples(0, i) = 0;
      }
    }
    return(actual_MVN_samples);
  }
}


